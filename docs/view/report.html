<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>pandas_profiling.view.report API documentation</title>
<meta name="description" content="Generate the report." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pandas_profiling.view.report</code></h1>
</header>
<section id="section-intro">
<p>Generate the report.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Generate the report.&#34;&#34;&#34;

import pandas as pd

import pandas_profiling.view.plot as plot
from pandas_profiling.view.plot import mini_histogram
from pandas_profiling.view.plot import histogram
import pandas_profiling.view.templates as templates
from pandas_profiling.config import config
from pandas_profiling.model.base import Variable
from pandas_profiling.model.messages import MessageType


def freq_table(
    freqtable, n: int, table_template, max_number_to_print: int, idx: int, nb_col=6
) -&gt; str:
    &#34;&#34;&#34;Render the HTML for a frequency table (value, count).

    Args:
      idx: The variable id.
      freqtable: The frequency table.
      n: The total number of values.
      table_template: The name of the template.
      max_number_to_print: The maximum number of observations to print.
      nb_col: The number of columns in the grid. (Default value = 6)

    Returns:
        The HTML representation of the frequency table.
    &#34;&#34;&#34;

    if max_number_to_print &gt; n:
        max_number_to_print = n

    if max_number_to_print &lt; len(freqtable):
        freq_other = sum(freqtable.iloc[max_number_to_print:])
        min_freq = freqtable.values[max_number_to_print]
    else:
        freq_other = 0
        min_freq = 0

    freq_missing = n - sum(freqtable)
    max_freq = max(freqtable.values[0], freq_other, freq_missing)

    # TODO: Correctly sort missing and other
    if max_freq == 0:
        raise ValueError(&#34;Empty column&#34;)

    rows = []
    for label, freq in freqtable.iloc[0:max_number_to_print].items():
        rows.append(
            {
                &#34;label&#34;: label,
                &#34;width&#34;: freq / max_freq,
                &#34;count&#34;: freq,
                &#34;percentage&#34;: float(freq) / n,
                &#34;extra_class&#34;: &#34;&#34;,
            }
        )

    if freq_other &gt; min_freq:
        rows.append(
            {
                &#34;label&#34;: &#34;Other values ({})&#34;.format(
                    str(freqtable.count() - max_number_to_print)
                ),
                &#34;width&#34;: freq_other / max_freq,
                &#34;count&#34;: freq_other,
                &#34;percentage&#34;: float(freq_other) / n,
                &#34;extra_class&#34;: &#34;other&#34;,
            }
        )

    if freq_missing &gt; min_freq:
        rows.append(
            {
                &#34;label&#34;: &#34;(Missing)&#34;,
                &#34;width&#34;: freq_missing / max_freq,
                &#34;count&#34;: freq_missing,
                &#34;percentage&#34;: float(freq_missing) / n,
                &#34;extra_class&#34;: &#34;missing&#34;,
            }
        )

    return templates.template(table_template).render(
        rows=rows, varid=hash(idx), nb_col=nb_col
    )


def extreme_obs_table(freqtable, number_to_print, n, ascending=True) -&gt; str:
    &#34;&#34;&#34;Similar to the frequency table, for extreme observations.

    Args:
      freqtable: The frequency table.
      number_to_print: The number of observations to print.
      n: The total number of observations.
      ascending: The ordering of the observations (Default value = True)

    Returns:
        The HTML rendering of the extreme observation table.
    &#34;&#34;&#34;
    # If it&#39;s mixed between base types (str, int) convert to str. Pure &#34;mixed&#34; types are filtered during type
    # discovery
    if &#34;mixed&#34; in freqtable.index.inferred_type:
        freqtable.index = freqtable.index.astype(str)

    sorted_freqtable = freqtable.sort_index(ascending=ascending)
    obs_to_print = sorted_freqtable.iloc[:number_to_print]
    max_freq = max(obs_to_print.values)

    rows = []
    for label, freq in obs_to_print.items():
        rows.append(
            {
                &#34;label&#34;: label,
                &#34;width&#34;: freq / max_freq if max_freq != 0 else 0,
                &#34;count&#34;: freq,
                &#34;percentage&#34;: float(freq) / n,
                &#34;extra_class&#34;: &#34;&#34;,
            }
        )

    return templates.template(&#34;freq_table.html&#34;).render(rows=rows)


def render_overview_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the overview HTML.

    Args:
        stats_object: The statistics to display in the overview.

    Returns:
        The rendered HTML for the overview component of the profile.
    &#34;&#34;&#34;
    return templates.template(&#34;overview.html&#34;).render(
        values=stats_object[&#34;table&#34;],
        messages=stats_object[&#34;messages&#34;],
        variables=stats_object[&#34;variables&#34;],
        MessageType=MessageType,
    )


def get_correlation_items(stats_object) -&gt; dict:
    &#34;&#34;&#34;Create the list of correlation items

    Args:
        stats_object: dict of correlations

    Returns:
        List of correlation items to show in the interface.
    &#34;&#34;&#34;
    items = {}
    if &#34;pearson&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;pearson&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;pearson&#34;]),
            &#34;name&#34;: &#34;Pearson&#39;s r&#34;,
        }

    if &#34;spearman&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;spearman&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;spearman&#34;]),
            &#34;name&#34;: &#34;Spearman&#39;s &amp;rho;&#34;,
        }

    if &#34;kendall&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;kendall&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;kendall&#34;]),
            &#34;name&#34;: &#34;Kendall&#39;s &amp;tau;&#34;,
        }

    if &#34;phi_k&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;phi_k&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;phi_k&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Phik (&amp;phi;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;)&#34;,
        }

    if &#34;cramers&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;cramers&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;cramers&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Cramér&#39;s V (&amp;phi;&lt;sub&gt;&lt;em&gt;c&lt;/em&gt;&lt;/sub&gt;)&#34;,
        }

    if &#34;recoded&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;recoded&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;recoded&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Recoded&#34;,
        }

    return items


def render_correlations_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the correlations HTML.

    Args:
        stats_object: The diagrams to display in the correlation component.

    Returns:
        The rendered HTML of the correlations component of the profile.
    &#34;&#34;&#34;
    items = get_correlation_items(stats_object)

    return templates.template(&#34;components/tabs.html&#34;).render(
        values=items, anchor_id=&#34;correlations&#34;
    )


def render_missing_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the missing values HTML.

    Args:
        stats_object: The diagrams with missing values.

    Returns:
        The missing values component HTML.
    &#34;&#34;&#34;
    return templates.template(&#34;components/tabs.html&#34;).render(
        values=stats_object[&#34;missing&#34;], anchor_id=&#34;missing&#34;
    )


def render_variables_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the HTML for each of the variables in the DataFrame.

    Args:
        stats_object: The statistics for each variable.

    Returns:
        The rendered HTML, where each row represents a variable.
    &#34;&#34;&#34;
    rows_html = u&#34;&#34;

    n_obs_unique = config[&#34;n_obs_unique&#34;].get(int)
    n_obs_bool = config[&#34;n_obs_bool&#34;].get(int)
    n_extreme_obs = config[&#34;n_extreme_obs&#34;].get(int)
    n_freq_table_max = config[&#34;n_freq_table_max&#34;].get(int)

    messages = stats_object[&#34;messages&#34;]

    # TODO: move to for loop in template
    for idx, row in stats_object[&#34;variables&#34;].items():
        formatted_values = row
        formatted_values.update({&#34;varname&#34;: idx, &#34;varid&#34;: hash(idx), &#34;row_classes&#34;: {}})

        # TODO: obtain from messages (ignore)
        for m in messages:
            if m.column_name == idx:
                if m.message_type == MessageType.SKEWED:
                    formatted_values[&#34;row_classes&#34;][&#34;skewness&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.HIGH_CARDINALITY:
                    # TODO: rename alert to prevent overlap with bootstrap classes
                    formatted_values[&#34;row_classes&#34;][&#34;distinct_count&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.ZEROS:
                    formatted_values[&#34;row_classes&#34;][&#34;zeros&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.MISSING:
                    formatted_values[&#34;row_classes&#34;][&#34;missing&#34;] = &#34;alert&#34;

        if row[&#34;type&#34;] in {Variable.TYPE_NUM, Variable.TYPE_DATE}:
            formatted_values[&#34;histogram&#34;] = histogram(
                row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins&#34;]
            )
            formatted_values[&#34;mini_histogram&#34;] = mini_histogram(
                row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins&#34;]
            )

            if (
                &#34;histogram_bins_bayesian_blocks&#34; in row
                and row[&#34;type&#34;] == Variable.TYPE_NUM
            ):
                formatted_values[&#34;histogram_bayesian_blocks&#34;] = histogram(
                    row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins_bayesian_blocks&#34;]
                )

        if row[&#34;type&#34;] in {Variable.TYPE_CAT, Variable.TYPE_BOOL}:
            # The number of column to use in the display of the frequency table according to the category
            mini_freq_table_nb_col = {Variable.TYPE_CAT: 6, Variable.TYPE_BOOL: 3}

            formatted_values[&#34;minifreqtable&#34;] = freq_table(
                stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                stats_object[&#34;table&#34;][&#34;n&#34;],
                &#34;mini_freq_table.html&#34;,
                max_number_to_print=n_obs_bool,
                idx=idx,
                nb_col=mini_freq_table_nb_col[row[&#34;type&#34;]],
            )

        if row[&#34;type&#34;] in {Variable.TYPE_URL}:
            keys = [&#34;scheme&#34;, &#34;netloc&#34;, &#34;path&#34;, &#34;query&#34;, &#34;fragment&#34;]
            for url_part in keys:
                formatted_values[&#34;freqtable_{}&#34;.format(url_part)] = freq_table(
                    freqtable=stats_object[&#34;variables&#34;][idx][
                        &#34;{}_counts&#34;.format(url_part)
                    ],
                    # TODO: n - missing
                    n=stats_object[&#34;table&#34;][&#34;n&#34;],
                    table_template=&#34;freq_table.html&#34;,
                    idx=idx,
                    max_number_to_print=n_freq_table_max,
                )

        if row[&#34;type&#34;] in {Variable.TYPE_PATH}:
            keys = [&#34;name&#34;, &#34;parent&#34;, &#34;suffix&#34;, &#34;stem&#34;]
            for path_part in keys:
                formatted_values[&#34;freqtable_{}&#34;.format(path_part)] = freq_table(
                    freqtable=stats_object[&#34;variables&#34;][idx][
                        &#34;{}_counts&#34;.format(path_part)
                    ],
                    # TODO: n - missing
                    n=stats_object[&#34;table&#34;][&#34;n&#34;],
                    table_template=&#34;freq_table.html&#34;,
                    idx=idx,
                    max_number_to_print=n_freq_table_max,
                )

        if row[&#34;type&#34;] == Variable.S_TYPE_UNIQUE:
            table = stats_object[&#34;variables&#34;][idx][
                &#34;value_counts_without_nan&#34;
            ].sort_index()
            obs = table.index

            formatted_values[&#34;firstn&#34;] = pd.DataFrame(
                list(obs[0:n_obs_unique]),
                columns=[&#34;First {} values&#34;.format(n_obs_unique)],
            ).to_html(classes=&#34;example_values&#34;, index=False)
            formatted_values[&#34;lastn&#34;] = pd.DataFrame(
                list(obs[-n_obs_unique:]),
                columns=[&#34;Last {} values&#34;.format(n_obs_unique)],
            ).to_html(classes=&#34;example_values&#34;, index=False)

        if row[&#34;type&#34;] not in {
            Variable.S_TYPE_UNSUPPORTED,
            Variable.S_TYPE_CORR,
            Variable.S_TYPE_CONST,
            Variable.S_TYPE_RECODED,
        }:
            formatted_values[&#34;freqtable&#34;] = freq_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                table_template=&#34;freq_table.html&#34;,
                idx=idx,
                max_number_to_print=n_freq_table_max,
            )

            formatted_values[&#34;n_extreme_obs&#34;] = n_extreme_obs
            formatted_values[&#34;firstn_expanded&#34;] = extreme_obs_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                number_to_print=n_extreme_obs,
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                ascending=True,
            )
            formatted_values[&#34;lastn_expanded&#34;] = extreme_obs_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                number_to_print=n_extreme_obs,
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                ascending=False,
            )

        if row[&#34;type&#34;] == Variable.TYPE_NUM:
            formatted_values[&#34;sections&#34;] = {
                &#34;statistics&#34;: {
                    &#34;name&#34;: &#34;Statistics&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_statistics.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;histogram&#34;: {
                    &#34;name&#34;: &#34;Histogram&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_histogram.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;frequency_table&#34;: {
                    &#34;name&#34;: &#34;Common values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_frequency_table.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;extreme_values&#34;: {
                    &#34;name&#34;: &#34;Extreme values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_extreme_values.html&#34;
                    ).render(values=formatted_values),
                },
            }

        if row[&#34;type&#34;] == Variable.TYPE_CAT:
            formatted_values[&#34;sections&#34;] = {
                &#34;frequency_table&#34;: {
                    &#34;name&#34;: &#34;Common values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_cat_frequency_table.html&#34;
                    ).render(values=formatted_values),
                }
            }

            check_compositions = config[&#34;vars&#34;][&#34;cat&#34;][&#34;check_composition&#34;].get(bool)
            if check_compositions:
                formatted_values[&#34;sections&#34;][&#34;composition&#34;] = {
                    &#34;name&#34;: &#34;Composition&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_cat_composition.html&#34;
                    ).render(values=formatted_values),
                }

        if row[&#34;type&#34;] == Variable.TYPE_URL:
            formatted_values[&#34;sections&#34;] = {
                &#34;full&#34;: {&#34;name&#34;: &#34;Full&#34;, &#34;value&#34;: formatted_values[&#34;freqtable&#34;]},
                &#34;scheme&#34;: {
                    &#34;name&#34;: &#34;Scheme&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_scheme&#34;],
                },
                &#34;netloc&#34;: {
                    &#34;name&#34;: &#34;Netloc&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_netloc&#34;],
                },
                &#34;path&#34;: {&#34;name&#34;: &#34;Path&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_path&#34;]},
                &#34;query&#34;: {
                    &#34;name&#34;: &#34;Query&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_query&#34;],
                },
                &#34;fragment&#34;: {
                    &#34;name&#34;: &#34;Fragment&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_fragment&#34;],
                },
            }

        if row[&#34;type&#34;] == Variable.TYPE_PATH:
            formatted_values[&#34;sections&#34;] = {
                &#34;full&#34;: {&#34;name&#34;: &#34;Full&#34;, &#34;value&#34;: formatted_values[&#34;freqtable&#34;]},
                &#34;stem&#34;: {&#34;name&#34;: &#34;Stem&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_stem&#34;]},
                &#34;name&#34;: {&#34;name&#34;: &#34;Name&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_name&#34;]},
                &#34;suffix&#34;: {
                    &#34;name&#34;: &#34;Suffix&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_suffix&#34;],
                },
                &#34;parent&#34;: {
                    &#34;name&#34;: &#34;Parent&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_parent&#34;],
                },
            }

        rows_html += templates.template(
            &#34;variables/row_{}.html&#34;.format(row[&#34;type&#34;].value.lower())
        ).render(values=formatted_values)
    return rows_html


def get_sample_items(sample: dict):
    &#34;&#34;&#34;Create the list of sample items

    Args:
        sample: dict of samples

    Returns:
        List of sample items to show in the interface.
    &#34;&#34;&#34;
    items = {}
    names = {&#34;head&#34;: &#34;First rows&#34;, &#34;tail&#34;: &#34;Last rows&#34;}
    for key in sample:
        items[key] = {
            &#34;name&#34;: names[key],
            &#34;value&#34;: &#39;&lt;div id=&#34;sample-container&#34; class=&#34;col-sm-12&#34;&gt;{}&lt;/div&gt;&#39;.format(
                sample[key].to_html(classes=&#34;sample table table-striped&#34;)
            ),
        }
    return items


def render_sample_section(sample: dict) -&gt; str:
    &#34;&#34;&#34;Render the sample HTML

    Args:
        sample: A dict containing samples from the dataset to print.

    Returns:
        The HTML rendering of the samples.
    &#34;&#34;&#34;
    items = get_sample_items(sample)

    return templates.template(&#34;components/list.html&#34;).render(values=items)


def to_html(sample: dict, stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Generate a HTML report from summary statistics and a given sample.

    Args:
      sample: A dict containing the samples to print.
      stats_object: Statistics to use for the overview, variables, correlations and missing values.

    Returns:
      The profile report in HTML format
    &#34;&#34;&#34;

    if not isinstance(sample, dict):
        raise TypeError(&#34;sample must be of type dict&#34;)

    if not isinstance(stats_object, dict):
        raise TypeError(
            &#34;stats_object must be of type dict. Did you generate this using the &#34;
            &#34;pandas_profiling.describe() function?&#34;
        )

    if not {&#34;table&#34;, &#34;variables&#34;, &#34;correlations&#34;}.issubset(set(stats_object.keys())):
        raise TypeError(
            &#34;stats_object badly formatted. Did you generate this using the pandas_profiling.describe() function?&#34;
        )

    sections = [
        {
            &#34;title&#34;: &#34;Overview&#34;,
            &#34;anchor_id&#34;: &#34;overview&#34;,
            &#34;content&#34;: render_overview_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Variables&#34;,
            &#34;anchor_id&#34;: &#34;variables&#34;,
            &#34;content&#34;: render_variables_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Correlations&#34;,
            &#34;anchor_id&#34;: &#34;correlations&#34;,
            &#34;content&#34;: render_correlations_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Missing values&#34;,
            &#34;anchor_id&#34;: &#34;missing&#34;,
            &#34;content&#34;: render_missing_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Sample&#34;,
            &#34;anchor_id&#34;: &#34;sample&#34;,
            &#34;content&#34;: render_sample_section(sample),
        },
    ]

    return templates.template(&#34;base.html&#34;).render(
        sections=sections, full_width=config[&#34;style&#34;][&#34;full_width&#34;].get(bool)
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pandas_profiling.view.report.extreme_obs_table"><code class="name flex">
<span>def <span class="ident">extreme_obs_table</span></span>(<span>freqtable, number_to_print, n, ascending=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Similar to the frequency table, for extreme observations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>freqtable</code></strong></dt>
<dd>The frequency table.</dd>
<dt><strong><code>number_to_print</code></strong></dt>
<dd>The number of observations to print.</dd>
<dt><strong><code>n</code></strong></dt>
<dd>The total number of observations.</dd>
<dt><strong><code>ascending</code></strong></dt>
<dd>The ordering of the observations (Default value = True)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTML rendering of the extreme observation table.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extreme_obs_table(freqtable, number_to_print, n, ascending=True) -&gt; str:
    &#34;&#34;&#34;Similar to the frequency table, for extreme observations.

    Args:
      freqtable: The frequency table.
      number_to_print: The number of observations to print.
      n: The total number of observations.
      ascending: The ordering of the observations (Default value = True)

    Returns:
        The HTML rendering of the extreme observation table.
    &#34;&#34;&#34;
    # If it&#39;s mixed between base types (str, int) convert to str. Pure &#34;mixed&#34; types are filtered during type
    # discovery
    if &#34;mixed&#34; in freqtable.index.inferred_type:
        freqtable.index = freqtable.index.astype(str)

    sorted_freqtable = freqtable.sort_index(ascending=ascending)
    obs_to_print = sorted_freqtable.iloc[:number_to_print]
    max_freq = max(obs_to_print.values)

    rows = []
    for label, freq in obs_to_print.items():
        rows.append(
            {
                &#34;label&#34;: label,
                &#34;width&#34;: freq / max_freq if max_freq != 0 else 0,
                &#34;count&#34;: freq,
                &#34;percentage&#34;: float(freq) / n,
                &#34;extra_class&#34;: &#34;&#34;,
            }
        )

    return templates.template(&#34;freq_table.html&#34;).render(rows=rows)</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.freq_table"><code class="name flex">
<span>def <span class="ident">freq_table</span></span>(<span>freqtable, n, table_template, max_number_to_print, idx, nb_col=6)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the HTML for a frequency table (value, count).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>idx</code></strong></dt>
<dd>The variable id.</dd>
<dt><strong><code>freqtable</code></strong></dt>
<dd>The frequency table.</dd>
<dt><strong><code>n</code></strong></dt>
<dd>The total number of values.</dd>
<dt><strong><code>table_template</code></strong></dt>
<dd>The name of the template.</dd>
<dt><strong><code>max_number_to_print</code></strong></dt>
<dd>The maximum number of observations to print.</dd>
<dt><strong><code>nb_col</code></strong></dt>
<dd>The number of columns in the grid. (Default value = 6)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTML representation of the frequency table.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def freq_table(
    freqtable, n: int, table_template, max_number_to_print: int, idx: int, nb_col=6
) -&gt; str:
    &#34;&#34;&#34;Render the HTML for a frequency table (value, count).

    Args:
      idx: The variable id.
      freqtable: The frequency table.
      n: The total number of values.
      table_template: The name of the template.
      max_number_to_print: The maximum number of observations to print.
      nb_col: The number of columns in the grid. (Default value = 6)

    Returns:
        The HTML representation of the frequency table.
    &#34;&#34;&#34;

    if max_number_to_print &gt; n:
        max_number_to_print = n

    if max_number_to_print &lt; len(freqtable):
        freq_other = sum(freqtable.iloc[max_number_to_print:])
        min_freq = freqtable.values[max_number_to_print]
    else:
        freq_other = 0
        min_freq = 0

    freq_missing = n - sum(freqtable)
    max_freq = max(freqtable.values[0], freq_other, freq_missing)

    # TODO: Correctly sort missing and other
    if max_freq == 0:
        raise ValueError(&#34;Empty column&#34;)

    rows = []
    for label, freq in freqtable.iloc[0:max_number_to_print].items():
        rows.append(
            {
                &#34;label&#34;: label,
                &#34;width&#34;: freq / max_freq,
                &#34;count&#34;: freq,
                &#34;percentage&#34;: float(freq) / n,
                &#34;extra_class&#34;: &#34;&#34;,
            }
        )

    if freq_other &gt; min_freq:
        rows.append(
            {
                &#34;label&#34;: &#34;Other values ({})&#34;.format(
                    str(freqtable.count() - max_number_to_print)
                ),
                &#34;width&#34;: freq_other / max_freq,
                &#34;count&#34;: freq_other,
                &#34;percentage&#34;: float(freq_other) / n,
                &#34;extra_class&#34;: &#34;other&#34;,
            }
        )

    if freq_missing &gt; min_freq:
        rows.append(
            {
                &#34;label&#34;: &#34;(Missing)&#34;,
                &#34;width&#34;: freq_missing / max_freq,
                &#34;count&#34;: freq_missing,
                &#34;percentage&#34;: float(freq_missing) / n,
                &#34;extra_class&#34;: &#34;missing&#34;,
            }
        )

    return templates.template(table_template).render(
        rows=rows, varid=hash(idx), nb_col=nb_col
    )</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.get_correlation_items"><code class="name flex">
<span>def <span class="ident">get_correlation_items</span></span>(<span>stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Create the list of correlation items</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stats_object</code></strong></dt>
<dd>dict of correlations</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of correlation items to show in the interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_correlation_items(stats_object) -&gt; dict:
    &#34;&#34;&#34;Create the list of correlation items

    Args:
        stats_object: dict of correlations

    Returns:
        List of correlation items to show in the interface.
    &#34;&#34;&#34;
    items = {}
    if &#34;pearson&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;pearson&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;pearson&#34;]),
            &#34;name&#34;: &#34;Pearson&#39;s r&#34;,
        }

    if &#34;spearman&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;spearman&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;spearman&#34;]),
            &#34;name&#34;: &#34;Spearman&#39;s &amp;rho;&#34;,
        }

    if &#34;kendall&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;kendall&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(stats_object[&#34;correlations&#34;][&#34;kendall&#34;]),
            &#34;name&#34;: &#34;Kendall&#39;s &amp;tau;&#34;,
        }

    if &#34;phi_k&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;phi_k&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;phi_k&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Phik (&amp;phi;&lt;sub&gt;&lt;em&gt;k&lt;/em&gt;&lt;/sub&gt;)&#34;,
        }

    if &#34;cramers&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;cramers&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;cramers&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Cramér&#39;s V (&amp;phi;&lt;sub&gt;&lt;em&gt;c&lt;/em&gt;&lt;/sub&gt;)&#34;,
        }

    if &#34;recoded&#34; in stats_object[&#34;correlations&#34;]:
        items[&#34;recoded&#34;] = {
            &#34;matrix&#34;: plot.correlation_matrix(
                stats_object[&#34;correlations&#34;][&#34;recoded&#34;], vmin=0
            ),
            &#34;name&#34;: &#34;Recoded&#34;,
        }

    return items</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.get_sample_items"><code class="name flex">
<span>def <span class="ident">get_sample_items</span></span>(<span>sample)</span>
</code></dt>
<dd>
<section class="desc"><p>Create the list of sample items</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong></dt>
<dd>dict of samples</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of sample items to show in the interface.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sample_items(sample: dict):
    &#34;&#34;&#34;Create the list of sample items

    Args:
        sample: dict of samples

    Returns:
        List of sample items to show in the interface.
    &#34;&#34;&#34;
    items = {}
    names = {&#34;head&#34;: &#34;First rows&#34;, &#34;tail&#34;: &#34;Last rows&#34;}
    for key in sample:
        items[key] = {
            &#34;name&#34;: names[key],
            &#34;value&#34;: &#39;&lt;div id=&#34;sample-container&#34; class=&#34;col-sm-12&#34;&gt;{}&lt;/div&gt;&#39;.format(
                sample[key].to_html(classes=&#34;sample table table-striped&#34;)
            ),
        }
    return items</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.render_correlations_section"><code class="name flex">
<span>def <span class="ident">render_correlations_section</span></span>(<span>stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the correlations HTML.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stats_object</code></strong></dt>
<dd>The diagrams to display in the correlation component.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rendered HTML of the correlations component of the profile.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_correlations_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the correlations HTML.

    Args:
        stats_object: The diagrams to display in the correlation component.

    Returns:
        The rendered HTML of the correlations component of the profile.
    &#34;&#34;&#34;
    items = get_correlation_items(stats_object)

    return templates.template(&#34;components/tabs.html&#34;).render(
        values=items, anchor_id=&#34;correlations&#34;
    )</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.render_missing_section"><code class="name flex">
<span>def <span class="ident">render_missing_section</span></span>(<span>stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the missing values HTML.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stats_object</code></strong></dt>
<dd>The diagrams with missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The missing values component HTML.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_missing_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the missing values HTML.

    Args:
        stats_object: The diagrams with missing values.

    Returns:
        The missing values component HTML.
    &#34;&#34;&#34;
    return templates.template(&#34;components/tabs.html&#34;).render(
        values=stats_object[&#34;missing&#34;], anchor_id=&#34;missing&#34;
    )</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.render_overview_section"><code class="name flex">
<span>def <span class="ident">render_overview_section</span></span>(<span>stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the overview HTML.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stats_object</code></strong></dt>
<dd>The statistics to display in the overview.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rendered HTML for the overview component of the profile.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_overview_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the overview HTML.

    Args:
        stats_object: The statistics to display in the overview.

    Returns:
        The rendered HTML for the overview component of the profile.
    &#34;&#34;&#34;
    return templates.template(&#34;overview.html&#34;).render(
        values=stats_object[&#34;table&#34;],
        messages=stats_object[&#34;messages&#34;],
        variables=stats_object[&#34;variables&#34;],
        MessageType=MessageType,
    )</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.render_sample_section"><code class="name flex">
<span>def <span class="ident">render_sample_section</span></span>(<span>sample)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the sample HTML</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong></dt>
<dd>A dict containing samples from the dataset to print.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The HTML rendering of the samples.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_sample_section(sample: dict) -&gt; str:
    &#34;&#34;&#34;Render the sample HTML

    Args:
        sample: A dict containing samples from the dataset to print.

    Returns:
        The HTML rendering of the samples.
    &#34;&#34;&#34;
    items = get_sample_items(sample)

    return templates.template(&#34;components/list.html&#34;).render(values=items)</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.render_variables_section"><code class="name flex">
<span>def <span class="ident">render_variables_section</span></span>(<span>stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Render the HTML for each of the variables in the DataFrame.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>stats_object</code></strong></dt>
<dd>The statistics for each variable.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The rendered HTML, where each row represents a variable.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def render_variables_section(stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Render the HTML for each of the variables in the DataFrame.

    Args:
        stats_object: The statistics for each variable.

    Returns:
        The rendered HTML, where each row represents a variable.
    &#34;&#34;&#34;
    rows_html = u&#34;&#34;

    n_obs_unique = config[&#34;n_obs_unique&#34;].get(int)
    n_obs_bool = config[&#34;n_obs_bool&#34;].get(int)
    n_extreme_obs = config[&#34;n_extreme_obs&#34;].get(int)
    n_freq_table_max = config[&#34;n_freq_table_max&#34;].get(int)

    messages = stats_object[&#34;messages&#34;]

    # TODO: move to for loop in template
    for idx, row in stats_object[&#34;variables&#34;].items():
        formatted_values = row
        formatted_values.update({&#34;varname&#34;: idx, &#34;varid&#34;: hash(idx), &#34;row_classes&#34;: {}})

        # TODO: obtain from messages (ignore)
        for m in messages:
            if m.column_name == idx:
                if m.message_type == MessageType.SKEWED:
                    formatted_values[&#34;row_classes&#34;][&#34;skewness&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.HIGH_CARDINALITY:
                    # TODO: rename alert to prevent overlap with bootstrap classes
                    formatted_values[&#34;row_classes&#34;][&#34;distinct_count&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.ZEROS:
                    formatted_values[&#34;row_classes&#34;][&#34;zeros&#34;] = &#34;alert&#34;
                elif m.message_type == MessageType.MISSING:
                    formatted_values[&#34;row_classes&#34;][&#34;missing&#34;] = &#34;alert&#34;

        if row[&#34;type&#34;] in {Variable.TYPE_NUM, Variable.TYPE_DATE}:
            formatted_values[&#34;histogram&#34;] = histogram(
                row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins&#34;]
            )
            formatted_values[&#34;mini_histogram&#34;] = mini_histogram(
                row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins&#34;]
            )

            if (
                &#34;histogram_bins_bayesian_blocks&#34; in row
                and row[&#34;type&#34;] == Variable.TYPE_NUM
            ):
                formatted_values[&#34;histogram_bayesian_blocks&#34;] = histogram(
                    row[&#34;histogramdata&#34;], row, row[&#34;histogram_bins_bayesian_blocks&#34;]
                )

        if row[&#34;type&#34;] in {Variable.TYPE_CAT, Variable.TYPE_BOOL}:
            # The number of column to use in the display of the frequency table according to the category
            mini_freq_table_nb_col = {Variable.TYPE_CAT: 6, Variable.TYPE_BOOL: 3}

            formatted_values[&#34;minifreqtable&#34;] = freq_table(
                stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                stats_object[&#34;table&#34;][&#34;n&#34;],
                &#34;mini_freq_table.html&#34;,
                max_number_to_print=n_obs_bool,
                idx=idx,
                nb_col=mini_freq_table_nb_col[row[&#34;type&#34;]],
            )

        if row[&#34;type&#34;] in {Variable.TYPE_URL}:
            keys = [&#34;scheme&#34;, &#34;netloc&#34;, &#34;path&#34;, &#34;query&#34;, &#34;fragment&#34;]
            for url_part in keys:
                formatted_values[&#34;freqtable_{}&#34;.format(url_part)] = freq_table(
                    freqtable=stats_object[&#34;variables&#34;][idx][
                        &#34;{}_counts&#34;.format(url_part)
                    ],
                    # TODO: n - missing
                    n=stats_object[&#34;table&#34;][&#34;n&#34;],
                    table_template=&#34;freq_table.html&#34;,
                    idx=idx,
                    max_number_to_print=n_freq_table_max,
                )

        if row[&#34;type&#34;] in {Variable.TYPE_PATH}:
            keys = [&#34;name&#34;, &#34;parent&#34;, &#34;suffix&#34;, &#34;stem&#34;]
            for path_part in keys:
                formatted_values[&#34;freqtable_{}&#34;.format(path_part)] = freq_table(
                    freqtable=stats_object[&#34;variables&#34;][idx][
                        &#34;{}_counts&#34;.format(path_part)
                    ],
                    # TODO: n - missing
                    n=stats_object[&#34;table&#34;][&#34;n&#34;],
                    table_template=&#34;freq_table.html&#34;,
                    idx=idx,
                    max_number_to_print=n_freq_table_max,
                )

        if row[&#34;type&#34;] == Variable.S_TYPE_UNIQUE:
            table = stats_object[&#34;variables&#34;][idx][
                &#34;value_counts_without_nan&#34;
            ].sort_index()
            obs = table.index

            formatted_values[&#34;firstn&#34;] = pd.DataFrame(
                list(obs[0:n_obs_unique]),
                columns=[&#34;First {} values&#34;.format(n_obs_unique)],
            ).to_html(classes=&#34;example_values&#34;, index=False)
            formatted_values[&#34;lastn&#34;] = pd.DataFrame(
                list(obs[-n_obs_unique:]),
                columns=[&#34;Last {} values&#34;.format(n_obs_unique)],
            ).to_html(classes=&#34;example_values&#34;, index=False)

        if row[&#34;type&#34;] not in {
            Variable.S_TYPE_UNSUPPORTED,
            Variable.S_TYPE_CORR,
            Variable.S_TYPE_CONST,
            Variable.S_TYPE_RECODED,
        }:
            formatted_values[&#34;freqtable&#34;] = freq_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                table_template=&#34;freq_table.html&#34;,
                idx=idx,
                max_number_to_print=n_freq_table_max,
            )

            formatted_values[&#34;n_extreme_obs&#34;] = n_extreme_obs
            formatted_values[&#34;firstn_expanded&#34;] = extreme_obs_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                number_to_print=n_extreme_obs,
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                ascending=True,
            )
            formatted_values[&#34;lastn_expanded&#34;] = extreme_obs_table(
                freqtable=stats_object[&#34;variables&#34;][idx][&#34;value_counts_without_nan&#34;],
                number_to_print=n_extreme_obs,
                n=stats_object[&#34;table&#34;][&#34;n&#34;],
                ascending=False,
            )

        if row[&#34;type&#34;] == Variable.TYPE_NUM:
            formatted_values[&#34;sections&#34;] = {
                &#34;statistics&#34;: {
                    &#34;name&#34;: &#34;Statistics&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_statistics.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;histogram&#34;: {
                    &#34;name&#34;: &#34;Histogram&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_histogram.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;frequency_table&#34;: {
                    &#34;name&#34;: &#34;Common values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_frequency_table.html&#34;
                    ).render(values=formatted_values),
                },
                &#34;extreme_values&#34;: {
                    &#34;name&#34;: &#34;Extreme values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_num_extreme_values.html&#34;
                    ).render(values=formatted_values),
                },
            }

        if row[&#34;type&#34;] == Variable.TYPE_CAT:
            formatted_values[&#34;sections&#34;] = {
                &#34;frequency_table&#34;: {
                    &#34;name&#34;: &#34;Common values&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_cat_frequency_table.html&#34;
                    ).render(values=formatted_values),
                }
            }

            check_compositions = config[&#34;vars&#34;][&#34;cat&#34;][&#34;check_composition&#34;].get(bool)
            if check_compositions:
                formatted_values[&#34;sections&#34;][&#34;composition&#34;] = {
                    &#34;name&#34;: &#34;Composition&#34;,
                    &#34;content&#34;: templates.template(
                        &#34;variables/row_cat_composition.html&#34;
                    ).render(values=formatted_values),
                }

        if row[&#34;type&#34;] == Variable.TYPE_URL:
            formatted_values[&#34;sections&#34;] = {
                &#34;full&#34;: {&#34;name&#34;: &#34;Full&#34;, &#34;value&#34;: formatted_values[&#34;freqtable&#34;]},
                &#34;scheme&#34;: {
                    &#34;name&#34;: &#34;Scheme&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_scheme&#34;],
                },
                &#34;netloc&#34;: {
                    &#34;name&#34;: &#34;Netloc&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_netloc&#34;],
                },
                &#34;path&#34;: {&#34;name&#34;: &#34;Path&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_path&#34;]},
                &#34;query&#34;: {
                    &#34;name&#34;: &#34;Query&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_query&#34;],
                },
                &#34;fragment&#34;: {
                    &#34;name&#34;: &#34;Fragment&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_fragment&#34;],
                },
            }

        if row[&#34;type&#34;] == Variable.TYPE_PATH:
            formatted_values[&#34;sections&#34;] = {
                &#34;full&#34;: {&#34;name&#34;: &#34;Full&#34;, &#34;value&#34;: formatted_values[&#34;freqtable&#34;]},
                &#34;stem&#34;: {&#34;name&#34;: &#34;Stem&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_stem&#34;]},
                &#34;name&#34;: {&#34;name&#34;: &#34;Name&#34;, &#34;value&#34;: formatted_values[&#34;freqtable_name&#34;]},
                &#34;suffix&#34;: {
                    &#34;name&#34;: &#34;Suffix&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_suffix&#34;],
                },
                &#34;parent&#34;: {
                    &#34;name&#34;: &#34;Parent&#34;,
                    &#34;value&#34;: formatted_values[&#34;freqtable_parent&#34;],
                },
            }

        rows_html += templates.template(
            &#34;variables/row_{}.html&#34;.format(row[&#34;type&#34;].value.lower())
        ).render(values=formatted_values)
    return rows_html</code></pre>
</details>
</dd>
<dt id="pandas_profiling.view.report.to_html"><code class="name flex">
<span>def <span class="ident">to_html</span></span>(<span>sample, stats_object)</span>
</code></dt>
<dd>
<section class="desc"><p>Generate a HTML report from summary statistics and a given sample.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sample</code></strong></dt>
<dd>A dict containing the samples to print.</dd>
<dt><strong><code>stats_object</code></strong></dt>
<dd>Statistics to use for the overview, variables, correlations and missing values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The</code> <code>profile</code> <code>report</code> <code>in</code> <code>HTML</code> <code>format</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_html(sample: dict, stats_object: dict) -&gt; str:
    &#34;&#34;&#34;Generate a HTML report from summary statistics and a given sample.

    Args:
      sample: A dict containing the samples to print.
      stats_object: Statistics to use for the overview, variables, correlations and missing values.

    Returns:
      The profile report in HTML format
    &#34;&#34;&#34;

    if not isinstance(sample, dict):
        raise TypeError(&#34;sample must be of type dict&#34;)

    if not isinstance(stats_object, dict):
        raise TypeError(
            &#34;stats_object must be of type dict. Did you generate this using the &#34;
            &#34;pandas_profiling.describe() function?&#34;
        )

    if not {&#34;table&#34;, &#34;variables&#34;, &#34;correlations&#34;}.issubset(set(stats_object.keys())):
        raise TypeError(
            &#34;stats_object badly formatted. Did you generate this using the pandas_profiling.describe() function?&#34;
        )

    sections = [
        {
            &#34;title&#34;: &#34;Overview&#34;,
            &#34;anchor_id&#34;: &#34;overview&#34;,
            &#34;content&#34;: render_overview_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Variables&#34;,
            &#34;anchor_id&#34;: &#34;variables&#34;,
            &#34;content&#34;: render_variables_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Correlations&#34;,
            &#34;anchor_id&#34;: &#34;correlations&#34;,
            &#34;content&#34;: render_correlations_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Missing values&#34;,
            &#34;anchor_id&#34;: &#34;missing&#34;,
            &#34;content&#34;: render_missing_section(stats_object),
        },
        {
            &#34;title&#34;: &#34;Sample&#34;,
            &#34;anchor_id&#34;: &#34;sample&#34;,
            &#34;content&#34;: render_sample_section(sample),
        },
    ]

    return templates.template(&#34;base.html&#34;).render(
        sections=sections, full_width=config[&#34;style&#34;][&#34;full_width&#34;].get(bool)
    )</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pandas_profiling.view" href="index.html">pandas_profiling.view</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pandas_profiling.view.report.extreme_obs_table" href="#pandas_profiling.view.report.extreme_obs_table">extreme_obs_table</a></code></li>
<li><code><a title="pandas_profiling.view.report.freq_table" href="#pandas_profiling.view.report.freq_table">freq_table</a></code></li>
<li><code><a title="pandas_profiling.view.report.get_correlation_items" href="#pandas_profiling.view.report.get_correlation_items">get_correlation_items</a></code></li>
<li><code><a title="pandas_profiling.view.report.get_sample_items" href="#pandas_profiling.view.report.get_sample_items">get_sample_items</a></code></li>
<li><code><a title="pandas_profiling.view.report.render_correlations_section" href="#pandas_profiling.view.report.render_correlations_section">render_correlations_section</a></code></li>
<li><code><a title="pandas_profiling.view.report.render_missing_section" href="#pandas_profiling.view.report.render_missing_section">render_missing_section</a></code></li>
<li><code><a title="pandas_profiling.view.report.render_overview_section" href="#pandas_profiling.view.report.render_overview_section">render_overview_section</a></code></li>
<li><code><a title="pandas_profiling.view.report.render_sample_section" href="#pandas_profiling.view.report.render_sample_section">render_sample_section</a></code></li>
<li><code><a title="pandas_profiling.view.report.render_variables_section" href="#pandas_profiling.view.report.render_variables_section">render_variables_section</a></code></li>
<li><code><a title="pandas_profiling.view.report.to_html" href="#pandas_profiling.view.report.to_html">to_html</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>